User 

prior to executing the command, start a new session, this way we will track all child processes also

ChatGPT

To ensure that your Python wrapper script starts a new session when executing the command, you can use the setsid function from the os module. By starting a new session, the command executed by subprocess.Popen becomes the session leader, which means all child processes spawned by this command will be part of this new session. This is especially useful for tracking and managing all related child processes more effectively.

Hereâ€™s how you can update your script to start a new session before executing the command:

python

#!/usr/bin/env python3

import subprocess
import sys
import time
import os
import argparse

def monitor_process(pid):
    """ Monitor and log basic details about the process. """
    try:
        # Check if the process is still running
        os.kill(pid, 0)
        print(f"Process {pid} is still running.")
    except OSError:
        print(f"Process {pid} has terminated.")

def main(command, args, sample_interval):
    """ A wrapper to execute a command, monitor and log the process details. """
    try:
        # Start the process
        print("Starting the command...")
        start_time = time.time()
        # Use setsid to start a new session
        process = subprocess.Popen([command] + args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, preexec_fn=os.setsid)

        # Monitor during execution
        try:
            while True:
                monitor_process(process.pid)
                if process.poll() is not None:
                    break
                time.sleep(sample_interval)  # Parameterized delay
        except KeyboardInterrupt:
            print("Monitoring interrupted.")

        # Collect outputs
        stdout, stderr = process.communicate()
        end_time = time.time()
        
        # Output results
        print(f"Command executed in {end_time - start_time:.2f} seconds.")
        print("STDOUT:", stdout.decode())
        print("STDERR:", stderr.decode())

    except Exception as e:
        print(f"Failed to execute command: {str(e)}")

if __name__ == "__main__":
    # Setup argparse to handle command line arguments
    parser = argparse.ArgumentParser(description="A process wrapper script that monitors the execution of a command.")
    parser.add_argument('command', help="The command to execute.")
    parser.add_argument('arguments', nargs='*', help="Arguments for the command.")
    parser.add_argument('--sample-interval', type=float, default=1.0, help="Interval in seconds between status checks of the running process.")
    
    args = parser.parse_args()

    main(args.command, args.arguments, args.sample_interval)

Key Changes:

    Added preexec_fn=os.setsid to subprocess.Popen. This function is called in the child process just before the child is executed. os.setsid() makes the child process a session leader, which gives it control over all child processes it may spawn, allowing you to track and manage these processes more effectively.

Usage:

This script should be saved, made executable (chmod +x wrapper.py), and can be run with:

bash

./wrapper.py ls --sample-interval 0.5

In this command, ls is the command being executed and monitored, and --sample-interval 0.5 specifies that the monitoring process checks the command's status every 0.5 seconds. The command and its children will run in a new session, making it easier to manage and terminate them collectively if needed.
